name: Build NixOS Config

on:
  workflow_dispatch:
  pull_request:
  push:
    branches:
      - main
      - staging
    paths-ignore:
      - "**/.git*"
      - "**/README.md"
      - "**/LICENSE"

jobs:
  detect_changes:
    runs-on: "ubuntu-latest"
    outputs:
      master_secrets_changed: ${{ steps.detect_changes.outputs.master_secrets_changed }}
      generated_secrets_changed: ${{ steps.detect_changes.outputs.generated_secrets_changed }}
      master_app_configs_changed: ${{ steps.detect_changes.outputs.master_app_configs_changed }}
      generated_app_configs_changed: ${{ steps.detect_changes.outputs.generated_app_configs_changed }}
    steps:
      - name: Checkout the repo
        uses: "actions/checkout@v4"

      - name: Detect changes
        uses: dorny/paths-filter@v3
        id: detect_changes
        with:
          filters: |
            master_secrets_changed:
              - org-config/secrets/master/**/*-secrets.yml
              - org-config/json/tunnels.d/**
            generated_secrets_changed:
              - org-config/secrets/generated/*.yml
            master_app_configs_changed:
              - org-config/app_configs/master/**/*-configs.yml
            generated_app_configs_changed:
              - org-config/app_configs/generated/*.yml

      - name: Debug output
        run: |-
          echo "master_secrets_changed: ${{ steps.detect_changes.outputs.master_secrets_changed }}"
          echo "generated_secrets_changed: ${{ steps.detect_changes.outputs.generated_secrets_changed }}"
          echo "master_app_configs_changed: ${{ steps.detect_changes.outputs.master_app_configs_changed }}"
          echo "generated_app_configs_changed: ${{ steps.detect_changes.outputs.generated_app_configs_changed }}"

  check_generation_ok:
    runs-on: "ubuntu-latest"
    needs: detect_changes
    outputs:
      # If the generated files have been changed,
      # then the auto-commit needs to be the last one in the git log
      # (pull_request && (master_secrets_changed || master_app_configs_changed)) -> (generated_files_changed && verify_generation.generation_ok)
      generation_ok: |-
        ${{
          ! github.event_name == 'pull_request' ||
          ! ( needs.detect_changes.outputs.master_secrets_changed == 'true' ||
              needs.detect_changes.outputs.master_app_configs_changed == 'true' ) ||
          (
            ( needs.detect_changes.outputs.generated_secrets_changed == 'true' ||
              needs.detect_changes.outputs.generated_app_configs_changed == 'true' ) &&
            steps.verify_generation.outputs.generation_ok == 'true'
          )
        }}
    steps:
      - name: "Checkout the repo"
        if: |-
          github.event_name == 'pull_request' && (
            needs.detect_changes.outputs.generated_secrets_changed ||
            needs.detect_changes.outputs.generated_app_configs_changed
          )
        uses: "actions/checkout@v4"
        with:
          # Checkout the actual PR HEAD and not the merge commit created by GitHub.
          ref: ${{ github.event.pull_request.head.sha }}
          persist-credentials: false
          # It is important to use a fetch-depth > 1, since otherwise,
          # with fetch-depth = 1, the single fetched commit will appear
          # to have modified all files in the repo.
          fetch-depth: 11

      - name: "Print the git log"
        if: |-
          github.event_name == 'pull_request' && (
            needs.detect_changes.outputs.generated_secrets_changed ||
            needs.detect_changes.outputs.generated_app_configs_changed
          )
        # We use max-count = fetch-depth - 1, since the final commit before
        # the shallow boundary will appear to contain all changes that have
        # not been fetched during the shallow clone.
        run: >-
          git log --max-count=10 --name-only

      - name: "Verify that the generated files are the last commit in the git log"
        id: verify_generation
        if: |-
          github.event_name == 'pull_request' && (
            needs.detect_changes.outputs.generated_secrets_changed == 'true' ||
            needs.detect_changes.outputs.generated_app_configs_changed == 'true'
          )
        # Grep has a non-zero exit code when no lines matched.
        # This means that the exit code will be non-zero unless the last commit:
        #   1. was made by the github-actions account
        #   2. modified the generated secrets or app_configs files
        # We need to run the grep command in a subshell to avoid
        # crashing the action when grep exits with a non-zero exit code
        # TODO make this more precise, check that the right file was modified
        run: |-
          grep_exit_code=$(
            set +e
            git log --max-count=1 --format=format:"%ae" --name-only | \
            grep --quiet --perl-regexp --null-data \
              "\+github-actions\[bot]@users\.noreply\.github\.com(\\norg-config/(secrets|app_configs)/generated/)+"
            echo "${?}"
            exit 0
          )
          if [ "${grep_exit_code}" -eq '0' ]; then
            generation_ok='true'
          else
            generation_ok='false'
          fi
          echo "Setting generation_ok to ${generation_ok}"
          echo "generation_ok=${generation_ok}" >> $GITHUB_OUTPUT

      - name: Debug output
        run: |-
          echo "event_name: ${{ github.event_name }}"
          echo "master_secrets_changed: ${{ needs.detect_changes.outputs.master_secrets_changed == 'true' }}"
          echo "generated_secrets_changed: ${{ needs.detect_changes.outputs.generated_secrets_changed == 'true' }}"
          echo "master_app_configs_changed: ${{ needs.detect_changes.outputs.master_app_configs_changed == 'true' }}"
          echo "generated_app_configs_changed: ${{ needs.detect_changes.outputs.generated_app_configs_changed == 'true' }}"
          echo "generation_ok: ${{ steps.verify_generation.outputs.generation_ok == 'true' }}"

  # Since this is the first job to build the pythontools packages,
  # we add an auth key to the cachix action to upload the package to cachix.
  # All other jobs needing the pythontools package should depend on this one.
  pre_build:
    runs-on: "ubuntu-latest"
    needs:
      - detect_changes
      - check_generation_ok
    outputs:
      files_pushed_outcome: ${{ steps.commit_push_step.outcome }}
    steps:
      # By default, when running on a PR, the checkout action will checkout
      # a detached HEAD. In order to be able to commit and push, we make sure
      # that we checkout the actual PR branch when we are going to push the secrets.
      # When the head branch is either main or staging, we don't commit secrets back
      # to these branches, since we cannot commit directly to them.
      - name: Checkout the repo (PR branch)
        id: checkout_pr_with_ref
        if: |-
          github.event_name == 'pull_request' && (
            needs.detect_changes.outputs.master_secrets_changed == 'true' ||
            needs.detect_changes.outputs.master_app_configs_changed == 'true'
          ) &&
          needs.check_generation_ok.outputs.generation_ok != 'true' &&
          !(contains(fromJson('["main", "staging"]'), github.event.pull_request.head.ref))
        uses: "actions/checkout@v4"
        with:
          ref: "${{ github.event.pull_request.head.ref }}"
          # Do not use the default GITHUB_TOKEN for authentication,
          # See: https://docs.github.com/en/actions/reference/authentication-in-a-workflow#using-the-github_token-in-a-workflow
          # This makes sure that the action gets retriggered after committing
          # the generated secrets, which is required for the PR validation.
          ssh-key: "${{ secrets.NIXOS_PUBLIC_COMMIT_KEY }}"

      - name: Checkout the repo (detached HEAD)
        if: steps.checkout_pr_with_ref.outcome == 'skipped'
        uses: "actions/checkout@v4"

      - name: Install the Nix package manager
        uses: cachix/install-nix-action@master
        with:
          github_access_token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Run formatting checks and lints"
        run: nix build '.#checks.x86_64-linux.pre-commit-check'

      - name: Clear the old generated secrets files
        run: |
          rm "./org-config/secrets/generated/generated-secrets.yml"
          rm "./org-config/app_configs/generated/generated-app-configs.yml"

      - name: Generate the new generated secrets files
        run: |-
          nix shell '.#nixostools' \
            --command encrypt_server_secrets \
            --ansible_vault_passwd '${{ secrets.NIXOS_SECRET_MANAGEMENT_VAULT_KEY }}' \
            --output_path          './org-config/secrets/generated/generated-secrets.yml' \
            --secrets_directory    './org-config/secrets/' \
            --tunnel_config_path   './org-config/json/tunnels.d/'

      - name: Generate the new server config files
        run: |-
          nix shell '.#nixostools' \
            --command generate_server_app_configs \
            --output_path          './org-config/app_configs/generated/generated-app-configs.yml'\
            --configs_directory    './org-config/app_configs/master/' \
            --tunnel_config_path   './org-config/json/tunnels.d/'

      - name: Commit and push the new generated secrets files
        # Only rerun this step if the master secrets have changed, but the auto-commit
        # is not the last commit of this PR, as checked by the check_secrets_ok job.
        # This avoids an infinite loop where the secrets keep on being regenerated.
        # If we skipped the checkout_pr_with_ref step above, it means we are not
        # supposed to commit back to the branch.
        if: steps.checkout_pr_with_ref.outcome != 'skipped'
        id: commit_push_step
        uses: "EndBug/add-and-commit@v9"
        with:
          add: "./org-config/secrets/generated/* ./org-config/app_configs/generated/*"
          message: |
            Commit newly generated files (GitHub Action: ${{ github.workflow }}).
          default_author: github_actions
          push: true

      - name: Update the NixOS Robot SSH keys
        id: do_update_keys
        if: |-
          steps.commit_push_step.outcome == 'skipped' && (
            github.event_name == 'push' ||
            github.event_name == 'workflow_dispatch'
          ) &&
          github.ref == 'refs/heads/main'
        run: |-
          nix shell '.#nixostools' \
            --command update_nixos_keys --api_token ${{ secrets.NIXOS_DEMO_KEY_MGMT_API_TOKEN }} \
            --nixos_config_dir   './org-config' \
            --tunnel_config_path './org-config/json/tunnels.d/'

      - name: Update the NixOS Robot SSH keys (dry run)
        if: |-
          steps.commit_push_step.outcome == 'skipped' &&
          steps.do_update_keys.outcome == 'skipped'
        run: |-
          nix shell '.#nixostools' \
            --command update_nixos_keys --api_token ${{ secrets.NIXOS_DEMO_KEY_MGMT_API_TOKEN }} \
            --nixos_config_dir   './org-config' \
            --tunnel_config_path './org-config/json/tunnels.d/' --dry_run

  # Generate the build matrix which will allows us to build each check in parallel.
  nix-matrix:
    runs-on: "ubuntu-latest"
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    needs:
      - pre_build
    # Only run this step if no new secrets or app_configs were pushed,
    # when either secrets or app_configs were pushed, this action will be
    # triggered again anyway because we added a new commit to the PR.
    if: needs.pre_build.outputs.files_pushed_outcome == 'skipped'
    steps:
      - name: Checkout the repo
        uses: "actions/checkout@v4"

      - name: Install the Nix package manager
        uses: "cachix/install-nix-action@master"
        with:
          github_access_token: ${{ secrets.GITHUB_TOKEN }}

      - id: set-matrix
        name: Generate Nix Matrix
        run: |
          set -Eeu

          # fast eval
          nix run .#nix-eval-jobs -- --flake '.#githubActions.matrix'

          # capture the output
          matrix="$(nix eval --json '.#githubActions.matrix')"

          echo "matrix=$matrix" >> "$GITHUB_OUTPUT"

  # Build each check exposed by the nix-matrix output.
  nix-build:
    name: ${{ matrix.name }} (${{ matrix.system }})
    needs: nix-matrix
    runs-on: ${{ matrix.os }}
    strategy:
      matrix: ${{ fromJSON(needs.nix-matrix.outputs.matrix) }}
    steps:
      - name: Checkout the repo
        uses: "actions/checkout@v4"

      - name: Install the Nix package manager
        uses: "cachix/install-nix-action@master"
        with:
          github_access_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Nix Build
        run: |
          nix build -L '.#${{ matrix.attr }}'

  build-installation-images:
    needs: nix-build
    runs-on: "ubuntu-latest"
    steps:
      - name: Checkout the repo
        uses: "actions/checkout@v4"

      - name: Install the Nix package manager
        uses: "cachix/install-nix-action@master"
        with:
          github_access_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Build the installation images
        run: |
          nix build .#rescue-iso-img

  # Run NixOS VM tests after the build step, but only if no new secrets or app_configs were pushed.
  # test:
  #   name: "test"
  #   runs-on: "ubuntu-latest"
  #   needs:
  #     - pre_build
  #   # Only run this step if no new secrets or app_configs were pushed,
  #   # when either secrets or app_configs were pushed, this action will be
  #   # triggered again anyway because we added a new commit to the PR.
  #   if: needs.pre_build.outputs.files_pushed_outcome == 'skipped'
  #   steps:
  #     - name: Checkout the repo
  #       uses: "actions/checkout@v4"
  #
  #     - name: Install the Nix package manager
  #       uses: "cachix/install-nix-action@master"
  #       with:
  #         github_access_token: ${{ secrets.GITHUB_TOKEN }}
  #
  #     - name: Build the NixOS VM tests
  #       run: nix build ".#checks.x86_64-linux.vmTests"
  deploy:
    runs-on: "ubuntu-latest"
    needs:
      - build-installation-images
    # We only want to deploy when commits have been pushed to main or staging.
    # The deployment simply triggers the nixos-upgrade service, so any server
    # that is being deployed will still pull it's config from the branch that's
    # configured in its config.
    if: |-
      ( github.event_name == 'push' ||
        github.event_name == 'workflow_dispatch' ) &&
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/staging')
    steps:
      - name: Auto-deploy the NixOS config to the requested servers
        uses: "MSF-OCB/Demo-NixOS-Deploy@main"
        with:
          nixos_robot_key: "${{ secrets.DEMO_ROBOT_KEY }}"
          nixos_deploy_fixed_hosts: >-
            demo-relay-1.ocb.msf.org
          nixos_deploy_service: "nixos-upgrade.service"
